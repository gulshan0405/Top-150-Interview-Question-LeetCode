Approaches

Brute Force->
1. Create a new array to store the merged result

We create an array merge of size m + n to hold the final sorted result.

2. Use two pointers to compare elements

size1 → pointer for nums1 (only the first m valid elements)

size2 → pointer for nums2

i → pointer for the merge array

3. Compare elements from both arrays

While both pointers are within bounds:

If nums1[size1] is smaller or equal, copy it to merge.

Otherwise, take the element from nums2.

This step keeps the merged result sorted.

4. Copy the remaining elements

If any elements are left in either array:

Copy leftover elements from nums1

Copy leftover elements from nums2

One of these loops will run, depending on which array still has elements.

5. Copy merged array back to nums1

Finally, copy all elements from merge[] into nums1[] so the result is stored in nums1.


Optimal Approach (In-place Merge from the End)
Why this works

nums1 has extra space at the end. Instead of merging from the front and overwriting values, we start from the back, placing the largest elements first. This avoids using extra space.

Steps
1. Set three pointers

i = m - 1 → last valid element in nums1

j = n - 1 → last element in nums2

k = m + n - 1 → last index of nums1 (final array position)

2. Compare and place elements

While both arrays have elements left:

If nums1[i] > nums2[j], place nums1[i] at nums1[k] and move i--.

Otherwise, place nums2[j] at nums1[k] and move j--.

Move k-- every time.

3. Copy remaining elements of nums2

If nums2 still has elements:

Copy them into nums1 from the front.

No need to copy nums1 elements, because they are already in place.

4. Result

Now nums1 contains all elements in sorted order without extra space.

Time and Space Complexity

Time Complexity: O(m + n)

Space Complexity: O(1) (in-place)