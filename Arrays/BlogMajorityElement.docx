Approach Explained Step by Step

The goal is to find the element that appears more than n/2 times.

Instead of counting every element, this algorithm cancels out different elements until only the majority element is left.

Step 1: Assume the first element is the majority
int majority = nums[0];
int count = 1;


You start by guessing that the first element might be the majority element.

count tracks how confident you are in that guess.

Step 2: Traverse the array
for (int i = 1; i < nums.length; i++) {


You check each element one by one.

Step 3: If count becomes 0, update the majority
if(count == 0){
    count++;
    majority = nums[i];
}


If count drops to 0, it means:

Your previous candidate has been fully canceled out.

You select a new candidate.

Set its count to 1.

Step 4: If the current number matches the candidate
else if (majority == nums[i]) {
    count++;
}


If the current number is the same as the current majority candidate:

Increase count.

This strengthens your confidence.

Step 5: If the current number is different
else {
    count--;
}


If the current number is different:

Decrease count (cancel them out).

This represents a “vote” against the current candidate.

Step 6: Return the final candidate
return majority;


After one full scan, the remaining candidate is guaranteed to be the majority element (because it appears more than n/2 times).

Why This Works

Whenever two different elements appear, they cancel each other out.

The majority element appears more than half of the time, so it will survive all cancellations and end up as the last standing candidate.

Time and Space

Time: O(n)

Space: O(1)
This is one of the most efficient solutions.