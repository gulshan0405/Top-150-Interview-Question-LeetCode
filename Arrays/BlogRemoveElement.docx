Step-by-step explanation of the approach
1) Create a pointer index = 0

This pointer marks the next position where you will place a number that is not equal to val.

You are basically building a new list inside the same array starting from position 0.

2) Loop through the entire array

You go through each element using i from 0 to nums.length - 1.

3) Check if the current element is not equal to val

If nums[i] != val, it means this element should stay in the array.

If it equals val, you skip it.

4) Copy only the valid elements to the front

Whenever you find a number that should be kept, you copy it to the position index:

nums[index] = nums[i]


Then increase index by 1:

index++


This effectively packs all valid elements at the beginning of the array.

5) Ignore elements equal to val

The elements equal to val are simply skipped.
Their original positions donâ€™t matter because the array is modified only in the front part.

6) After the loop ends, return index

index tells you how many valid elements remain in the array.

That is the final length of the array without the removed value.

Summary of what this method achieves

It removes all occurrences of val in-place, without using extra space.

It reshapes the array so that the first index positions contain the valid elements.

The method returns that new length.