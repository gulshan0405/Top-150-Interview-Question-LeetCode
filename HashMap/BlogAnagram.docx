✅ Approach 1: Frequency Array Method (Most Efficient)
Code logic
if (s.length() != t.length()) return false;

int[] count = new int[26];

for (int i = 0; i < s.length(); i++) {
    count[s.charAt(i) - 'a']++;
    count[t.charAt(i) - 'a']--;
}

for (int c : count) {
    if (c != 0) return false;
}

return true;

Step-by-Step Explanation

If lengths differ, they cannot be anagrams.
Because anagrams must have the same number of characters.

Create an array of size 26.
This represents counts for each letter 'a' to 'z'.

Loop through both strings at the same time.

Increase count for characters of s

Decrease count for characters of t

Why this works?
If both strings have the same letters with the same frequency, all counts will end up as zero.

Check the count array.
If any value is not zero, then frequencies don’t match → return false.

If all are zero, return true.

✅ Approach 2: Sorting Method
Code logic
if(s.length()!=t.length()){
    return false;
}
int []arr=new int[s.length()];
int []brr=new int[t.length()];

for(int i=0;i<s.length();i++){
    arr[i]=s.charAt(i)+1;
    brr[i]=t.charAt(i)+1;
}

Arrays.sort(arr);
Arrays.sort(brr);

for(int i=0;i<arr.length;i++){
    if(arr[i]!=brr[i]){
       return false;
    }
}
return true;

Step-by-Step Explanation

Check length first.
If different → not anagrams.

Convert characters to numeric form.
You stored character codes (char + 1) in arrays.

Sort both arrays.
Sorting puts characters in the same order if they are anagrams.

Compare both arrays element by element.

If any mismatch → not anagrams

If all match → they are anagrams

❇️ Approach 3: HashMap Frequency Method (Your Final Code)
Code logic
if (s.length() != t.length()) {
    return false;
}

HashMap<Character, Integer> map = new HashMap<>();

// build frequency from s
for (char c : s.toCharArray()) {
    map.put(c, map.getOrDefault(c, 0) + 1);
}

// subtract using t
for (char c : t.toCharArray()) {
    if (!map.containsKey(c)) {
        return false;
    }
    map.put(c, map.get(c) - 1);

    if (map.get(c) == 0) {
        map.remove(c);
    }
}

return map.isEmpty();

Step-by-Step Explanation

Check length of strings.
If not equal → cannot be anagrams.

Create a HashMap for frequency counting.
Key = character
Value = count of that character

Count characters from string s.

For each char, increase its count

Use getOrDefault to avoid null values

Reduce the count using string t.

If a character in t is not in the map → return false

Decrease its count

Remove characters whose count becomes zero.
This keeps the map clean and efficient.

Finally check if map is empty.

Empty map means all characters matched

So the strings are anagrams

⭐ Which Approach is Best?
Approach	Time Complexity	Space	Notes
Frequency Array	O(n)	O(1)	Fastest, works only for lowercase letters
Sorting	O(n log n)	O(1) or O(n)	Simple but slower
HashMap	O(n)	O(1)/O(n)	Works for Unicode chars too